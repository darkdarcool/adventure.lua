{"note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","body":"**Important**: If you haven't played one of the example adventures yet go ahead and mess around with [xample land](https://github.com/shawndumas/adventure.lua/blob/master/xampleLand.lua) now. If you don't have Lua installed yet and you are on windows what you want is [Lua for Windows](http://code.google.com/p/luaforwindows/). For the mac, install [Homebrew](http://mxcl.github.com/homebrew/), and then do \"brew install lua\" from the terminal. For linux... well, you probably already know what to do if you are rocking a linux distro.\r\n\r\n### State + Event --> State ==> Invocation\r\n\r\nThe main dispatch table for any adventure program will look something like this:\r\n\r\n    locations = makeFSM({\r\n        { 'room00', 'examine', 'room00', fruitless_examination },\r\n        { 'room00', 'north',   'room01', room00_north_room01 },\r\n        { 'room01', 'examine', 'room01', room01_examine_room01 },\r\n        { 'room01', 'north',   'room02', room01_north_room02 },\r\n        { 'room01', 'south',   'room00', room01_south_room00 },\r\n        { 'room02', 'examine', 'room02', fruitless_examination },\r\n        { 'room02', 'south',   'room01', room02_south_room01 },\r\n        -- default starting area\r\n        { 'start',  'begin',   'room00', start_begin_room00 }\r\n    })\r\n\r\nThe four fields in each of the rows are:\r\n\r\n1. the initial _state_ (the location the player started in)\r\n\r\n1. an _event_ (the command the player chooses)\r\n\r\n1. the new _state_ (the location the player will end up at)\r\n\r\n1. the function that gets invoked\r\n\r\nOr stated another way:\r\n\r\n    [initial state] + [an event] --> [new state] ==> [invocation]\r\n\r\nDuring the main loop the player is repeatedly asked to choose a command. If a player were in the _state_ [room00], ie. the location 'room00', and chose the _event_ [north], ie. the command North, then the dispatch row that matches will have its corresponding function invoked. \r\n\r\nThe matching dispatch row would look like this:\r\n\r\n    { 'room00', 'north', 'room01', room00_north_room01 }\r\n\r\nThat function will be invoked with two parameters; the _event_ [north], which was the command chosen by the player, and the new _state_ [room01], which is the player's new location.\r\n\r\nLet's see what that particular function might look like:\r\n\r\n    local function room00_north_room01 (event, state)\r\n        return function ()\r\n            gbl.description = \"the description of room01...\"\r\n            gbl.options = {\r\n                s = 'Go South; back to room00 (whence we came)'\r\n            }\r\n            return state\r\n        end\r\n    end\r\n\r\n(You may have noticed that the function returns an anonymous function. And that the inner function returns the _state_ that the location creation function passes in. If that's confusing don't worry about it for now. Especially if all you want to do is make new adventures. All we are concerned with now is that inner function.)\r\n\r\nThe inner function does three things:\r\n\r\n1. the setting of the property gbl.description to a description of the now current location\r\n\r\n1. the setting of the property gbl.options with new commands that are now available to the player\r\n\r\n1. returning the _state_ which is now the location called [room01]\r\n\r\nRemember, the process is:\r\n\r\n    [initial state] + [an event] --> [new state] ==> [invocation]\r\n\r\nIn doing it this way one can do things other than just moving from location to location. For example look at the rows that include the _event_ [examine]:\r\n\r\n    { 'room00', 'examine', 'room00', fruitless_examination },\r\n    { 'room01', 'examine', 'room01', room01_examine_room01 },\r\n    { 'room02', 'examine', 'room02', fruitless_examination },\r\n\r\nThe player starts in a location, chooses the _event_ [examine] and they end up in the same location. Let's see what that particular function might look like:\r\n\r\n    function room01_examine_room01 (event, state)\r\n        return function ()\r\n            if not detectinventoryitem('someitem') then\r\n                print(wrap('\\n\\nYou discover some item.')\r\n                insertinventoryitem('someitem')\r\n            else\r\n                print('\\nYour examination is fruitless.\\n')\r\n            end\r\n            entertocontinue()\r\n            return state\r\n        end\r\n    end\r\n\r\nThis function starts out by looking in the player's inventory. If the player hasn't already found the item 'someitem' it prints a message indicating that that item was found and then performs an insertion of that item into the player's inventory. If the player already had that item then the function prints a message indicating that nothing was found. It then returns the same _state_, the location [room01], so that the player will remain in the location in which the _event_ [examine] was chosen as a command by the player.\r\n\r\nRemember, we used the same dispatch table to process the two _events_ [north] and [examine], two very different _events_, in order to move the player [north] and to process the command [examine]. This flexibility allows the programmer to create new _events_ at will. And not just those already listed. Take, for example, an infinite location. Here, first, the dispatch table rows:\r\n\r\n    { 'meadow', 'south', 'meadow', meadow_south_meadow },\r\n    { 'meadow', 'west',  'meadow', meadow_west_meadow },\r\n\r\nAnd now the corresponding functions:\r\n\r\n    local function neverendingmeadow (event, state)\r\n        return function ()\r\n            gbl.description = \"Flies; little tiny flies everywhere.\"\r\n            gbl.options = {\r\n                n = 'Go North; to the clearing',\r\n                s = 'Go South; continuing in to the meadow',\r\n                w = 'Go West; continuing in to the meadow'\r\n            }\r\n            if not detectinventoryitem('the_small_fly') then\r\n                insertcommand('c', 'catch')\r\n                gbl.options.c = 'Catch one; if you can'\r\n            end\r\n            return state\r\n        end\r\n    end\r\n\r\n    local function meadow_south_meadow (event, state)\r\n        return neverendingmeadow(event, state)\r\n    end\r\n\r\n    local function meadow_west_meadow (event, state)\r\n        return neverendingmeadow(event, state)\r\n    end\r\n\r\nNotice that the player will never leave the [meadow] by going [south] or [west]. Notice also that we inserted a new _event_ into the table of possible commands (if an inventory item was not detected, that is). If the new _event_ [catch], an ad hoc command, is chosen in the _state_ [meadow], a location, the adventure engine will index the dispatch looking for a row that looks like this:\r\n\r\n    { 'meadow', 'catch', 'meadow', meadow_catch_meadow },\r\n\r\nAnd invoke its corresponding function that might look like this:\r\n\r\n    local function meadow_catch_meadow (event, state)\r\n        return function ()\r\n            gbl.description = \"The flies are fast and wary but you finally catch one.\"\r\n            gbl.options = {\r\n                n = 'Go North; to the clearing',\r\n                s = 'Go South; continuing in to the meadow',\r\n                w = 'Go West; continuing in to the meadow'\r\n            }\r\n            insertinventoryitem('the_small_fly')\r\n            return state\r\n        end\r\n    end\r\n\r\nOne could create any number of ad hoc _events_ and _states_ in this way. (Just be sure to delete the ad hoc _event_ when the player leaves the associated _state_; like so.)\r\n\r\n    deletecommand('c')\r\n\r\nSo, as you see, having the dispatch table designed in the following manner...\r\n\r\n    [initial state] + [an event] --> [new state] ==> [invocation]\r\n\r\n... affords amazing flexibility with a very simple to program mechanic.\r\n\r\n### Verb + Noun + Predicate + Noun ==> Invocation\r\n\r\nThe interaction of one item in the player's inventory against another item is called an action. Actions work by first creating a function to be invoked upon the player successfully applying one item to another using the verb(s) and predicate(s) you insert in the actions table.\r\n\r\nConsider the following example:\r\n\r\n    local function makeaconundrum ()\r\n        return function (t)\r\n            return function ()\r\n                local r = stringifyaction(t)\r\n                r = r .. '\\n\\n[You have (somehow) gotten the square peg into the round hole. (Good job!)]'\r\n                deleteinventoryitem({\r\n                    'the_proverbial_square_peg',\r\n                    'the_inevitable_round_hole',\r\n                })\r\n                insertinventoryitem('a_conundrum')\r\n                return r\r\n            end\r\n        end\r\n    end\r\n\r\n(Again you'll noticed that the function returns a function that returns another function. If that's confusing don't worry about it for now. Especially if all you want to do is make new adventures. All we are concerned with now are the two inner functions.) The first inner function is passed a table (here called 't') that consistent of the verb, the first noun, the predicate, and the second noun that were chosen by the user. This table is accessible to the innermost function and, in this example, is simply passed to the function called 'stringifyaction' and the return value is captured by 'r'.\r\n\r\nThe function 'stringifyaction' turns the table in to a sentence much like the following:\r\n\r\n    You put the proverbial square peg in the inevitable round hole.\r\n\r\n(Notice that the underscores are replaced with spaces.) That's just the verb, the first noun, the predicate, and the second noun selected by the player.\r\n\r\nAfter the capture, the innermost function appends the success message, deletes some inventory items, and then adds an inventory item. The innermost function finally returns a string (here called 'r'). The value of 'r' is, in this case:\r\n\r\n    You put the proverbial square peg in the inevitable round hole.\r\n\r\n    [You have (somehow) gotten the square peg into the round hole. (Good job!)]\r\n\r\nIn order for the player to eventually cause the invocation of that function they must complete an inventory action that you create. Let's look at one that uses the discussed function now:\r\n\r\n    insertaction(\r\n        actions,\r\n        {\r\n            verbs = {\r\n                'drop',\r\n                'push',\r\n                'put',\r\n            },\r\n            nouns = {\r\n                first = { 'the_proverbial_square_peg' },\r\n                second = { 'the_inevitable_round_hole' }\r\n            },\r\n            predicates = {\r\n                'in',\r\n            }\r\n        },\r\n        makeaconundrum()\r\n    )\r\n\r\nWhat's going on here is the insertion of an action in to the table of actions available to the player (assuming they have the specified items in their inventory of course). The first parameter is the table that the action will be inserted in to. The second is a table of tables that declare which verb-noun-predicate-noun choices will trigger the invocation of the third parameter, a function. In this case the player could pick any of the following:\r\n\r\n    drop -- the_proverbial_square_peg -- in -- the_inevitable_round_hole\r\n    push -- the_proverbial_square_peg -- in -- the_inevitable_round_hole\r\n    put  -- the_proverbial_square_peg -- in -- the_inevitable_round_hole\r\n\r\nEither of the nouns' tables can have more than one item. The end result is that the action can start with either noun and then end with the other. See the following:\r\n\r\n    nouns = {\r\n        first = {\r\n            'the_rock',\r\n            'the_stone'\r\n        },\r\n        second = {\r\n            'the_rock',\r\n            'the_stone'\r\n        }\r\n\r\nIn the previous instance if the player started with the rock then the second list provided to the player will not contain the rock but will contain the stone. Conversely, if the player started with the stone then the stone would be excluded and the rock would be listed in the second list of nouns. As in:\r\n\r\n    hit -- the_rock  -- on -- the_stone\r\n    hit -- the_stone -- on -- the_rock\r\n\r\nOr, like the following nouns table, where the noun in the first table can be applied successfully to any of the nouns in the second table:\r\n\r\n    nouns = {\r\n        first = { 'the_small_fly' },\r\n        second = {\r\n            'the_fishing_rod',\r\n            'the_hook_shaped_bone',\r\n            'the_hook_and_vine'\r\n        }\r\n    }\r\n\r\nIncidentally here are the tables representing all possible verbs and predicates:\r\n\r\n    local allverbs = {\r\n        'drop',\r\n        'hit',\r\n        'pull',\r\n        'push',\r\n        'put',\r\n        'throw',\r\n        'touch',\r\n        'use',\r\n    }\r\n\r\n    local allpredicates = {\r\n        'after',\r\n        'apart_from',\r\n        'at',\r\n        'before',\r\n        'in',\r\n        'on',\r\n        'over',\r\n        'to',\r\n        'with',\r\n        'under',\r\n    }\r\n\r\n### Settings, settings, and settings\r\n\r\nThe first set of settings are a table called game used by the adventure engine to determine certain default values. The following is an example game table (from [xampleLand.lua](https://github.com/shawndumas/adventure.lua/blob/master/xampleLand.lua))\r\n\r\n    game = {\r\n      done = false,\r\n      stop = false,\r\n      filename = 'xampleLand.save.txt',\r\n      defaultname = 'Friend',\r\n      introtext = wrap(\"\\nWelcome {name}, This is an example adventure. Not much fun as a game though, sorry.\")\r\n    }\r\n\r\nThe sections are;\r\n  1. **done**: Has the player died or won.\r\n  1. **stop**: end the main loop exiting the game.\r\n  1. **filename**: the name of the save-file for this adventure.\r\n  1. **defaultname**: What the player's name will be if they opt not to supply one.\r\n  1. **introtext**: The text that gets display initially. (Notice the use of the helper function wrap in the above example.)\r\n\r\nRounding out a tour of a minimal adventure is the invocation of the go function. Two tables need to be passed to the go function. The first is a table containing the settings for the adventure proper. The following is an example settings table (from [xampleLand.lua](https://github.com/shawndumas/adventure.lua/blob/master/xampleLand.lua)):\r\n\r\n    local settings = {\r\n      name = nil,\r\n      roomswithenemies = {\r\n        'room01',\r\n        'room02'\r\n      },\r\n      commands = {\r\n        n = 'north',\r\n        s = 'south',\r\n        e = 'east',\r\n        w = 'west',\r\n        x = 'examine'\r\n      },\r\n      enemytypes = {\r\n        'tiny_drone',\r\n        'small_drone',\r\n        'drone',\r\n        'large_drone'\r\n      },\r\n      inventory = {\r\n        'the_inevitable_round_hole'\r\n      },\r\n      conditions = {\r\n        timesinroom00 = 1\r\n      }\r\n    }\r\n\r\n(Note: This table, with a few additional values, is the table that is used to create a save file.)\r\n\r\nThe sections are;\r\n  1. **name**: The name that the player choose when prompted.\r\n  1. **roomswithenemies**: What rooms can an enemy be in. (Note: enemies will be in one of these rooms each turn.)\r\n  1. **commands**: for command translation from single letter to full command.\r\n  1. **enemytypes**: The names for the various enemies, from weakest to strongest (only four unless you make cfg.enemy.maxhp > 4).\r\n  1. **inventory**: The hero's items, stick items that you want the player to have at game start.\r\n  1. **conditions**: For recording author configurable states, events, and conditions.\r\n\r\nThe second table is for the fighting sub-engine. The following is an example fight settings table (from [xampleLand.lua](https://github.com/shawndumas/adventure.lua/blob/master/xampleLand.lua)):\r\n\r\n    local fightsettings = {\r\n      hero = {\r\n        hitmin = 3,\r\n        hitmax = 5,\r\n        tohit = 5\r\n      },\r\n      enemy = {\r\n        hitmin = 2,\r\n        hitmax = 7,\r\n        mintohit = 4,\r\n        maxtohit = 5,\r\n        minhp = 1,\r\n        maxhp = 4,\r\n        hitmod = 3\r\n      }\r\n    }\r\n\r\nThe sections are;\r\n  1. **hero**: Settings for the player...\r\n    1. **hitmin**: Where the player start out at. (As in, heroattack = math.random(cfg.hero.hitmin, cfg.hero.hitmax).)\r\n    1. **hitmax**: The maximum amount of bad-ass-ness the player can be raised to. (As in, heroattack = math.random(cfg.hero.hitmin, cfg.hero.hitmax).)\r\n    1. tohit : What the hero has to beat to hit the enemy. (As in, heroattack > cfg.hero.tohit.)\r\n  1. **enemy**: Settings for the player's enemies...\r\n    1. **hitmin**: The first number passed to math.random when determining a hit. (As in, enemyattack = math.random(cfg.enemy.hitmin, cfg.enemy.hitmax).)\r\n    1. **hitmax**: The second number passed to math.random when determining a hit. (As in, enemyattack = math.random(cfg.enemy.hitmin, cfg.enemy.hitmax).)\r\n    1. **mintohit**: The min of what an enemy has to beat to hit the hero (the enemy is savage)\r\n    1. **maxtohit**: The max of what an enemy has to beat to hit the hero (the enemy is menacing)\r\n    1. **minhp**: The min hit points for an enemy (this matches the enemytypes).\r\n    1. **maxhp**: The max hit points for an enemy (this matches the enemytypes).\r\n    1. **hitmod**: The difference between the maxtohit and the two types of enemies (menacing, savage)\r\n\r\n[Check out this very small example adventure](https://github.com/shawndumas/adventure.lua/blob/master/xampleLand.lua)","name":"Adventure.lua","tagline":"Lua Text Adventure Engine"}